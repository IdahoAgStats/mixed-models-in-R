# Lattice Design

```{r, include=FALSE, echo=FALSE}
source(here::here("settings.r"))

par(mar=c(5.1, 6, 4.1, 2.1))
```

## Background

alpha lattice design 

Lattice designs are a well-known type of resolvable incomplete block design. Lattice designs are convenient for when there is a large number of treatments so that the block size is too big to control for spatial variation effectively. These lattice designs were first developed by Yates [-@yates_1936] and later, alpha lattice designs were developed as an extension [@patterson_1976]. A special feature of lattice designs is that the number of treatments, t, is related to the block size, k, in one of three forms: t = k^2^, t = k^3^, or t = k(k + 1).

Even though the number of possible treatments is limited, a lattice design may be an ideal design for field experiments with a large number of treatments.

Statistical model for lattice design:

$Y_{ijk} = \mu + \alpha_i + \gamma_j + \tau_t  + \beta_k + \epsilon_ijk$

where, $\mu$ is the experiment mean, ùõΩ is the row effect, ùõæ is the column effect, and ùúè is the treatment effect.

## Example Analysis

Let's start the analysis firstly by loading the required libraries:

::: panel-tabset
### lme4

```{r, message=FALSE, warning=FALSE}
library(lme4); library(lmerTest); library(emmeans); library(performance)
library(dplyr); library(broom.mixed); library(agridat); library(desplot)
```

### nlme
```{r, message=FALSE, warning=FALSE}
library(nlme); library(broom.mixed); library(emmeans); library(performance)
library(dplyr); library(agridat); library(desplot)
```
:::

The data used in this example is extracted from the `agridat` package. This data is a balanced lattice experiment in cotton containing 16 treatments in a 4x4 layout in each of 5 replicates. The response variable in this data is the percentage of young flower buds attacked by boll weevils.
```{r}
data(cochran.lattice)
dat3 <- agridat::cochran.lattice
head(dat2)
```
|       |                              |
|-------|------------------------------|
| rep   | replication unit             |
| trt   | treatment factor                |
| row   | row position for each plot        |
| col   | column position for each plot    |
| y | % of young flower buds attacked        |

: Table of variables in the data set {tbl-lattice}


```{r}
str(dat3)
```

```{r}
library(desplot)
desplot(dat3, y~row*col|rep,
        text=trt, # aspect unknown, should be 2 or .5
         main="cochran.lattice")

```

```{r}
data(burgueno.rowcol)
dat <- burgueno.rowcol
head(dat)
```

Here, we can use the `desplot()` function from the 'desplot' package to visualize the plot plan from lattice design.

```{r}
# Two contiuous reps in 8 rows, 16 columns
desplot(dat, yield ~ col*row,
        out1=rep, # aspect unknown
        text=gen, shorten="none", cex=0.75,
        main="lattice design")

```

### Data integrity checks
```{r, echo=FALSE}
#| label: lattice_design
#| fig-cap: "Histogram of the dependent variable."
#| column: margin
par(mar=c(5.1, 5, 2.1, 2.1))
desplot(dat, yield ~ col*row,
        out1=rep, # aspect unknown
        text=gen, shorten="none", cex=.75,
        main="burgueno.rowcol")
```
### Data integrity checks

```{r}
str(dat)
```

```{r}
dat2$row <- as.factor(dat2$row)
dat2$col <- as.factor(dat2$col)

dat$row <- as.factor(dat$row)
dat$col <- as.factor(dat$col)
```

```{r, eval=FALSE}
hist(dat2$y, main = "", xlab = "yield")
```

```{r, echo=FALSE}
#| label: fig-rcbd_hist
#| fig-cap: "Histogram of the dependent variable."
#| column: margin
par(mar=c(5.1, 5, 2.1, 2.1))
hist(dat$yield, main = "", xlab = "yield", cex.lab = 1.8, cex.axis = 1.5)
```

::: panel-tabset
### lme4

```{r}
m1_a <- lmer(yield ~ gen + (1|row) + (1|col:rep) + (1|rep),
           data = dat,
           na.action = na.exclude)
summary(m1_a) 
```

### nlme

```{r}
dat$dummy <- factor(1)

m1_b <- lme(yield ~ gen,
          random = list(dummy = pdBlocked(list(
                                  pdIdent(~row - 1),
                                  pdIdent(~rep - 1),
                                  pdIdent(~col:rep)))),
          data = dat, 
          na.action = na.exclude)

VarCorr(m1_b)
```
:::

### Check Model Assumptions

Remember those iid assumptions? Let's make sure we actually met them.

```{r, fig.height=9}
check_model(m1_a)
```


### Inference

Estimates for each treatment level can be obtained with the 'emmeans' package. And we can extract the ANOVA table from model using `anova()` function.

```{r}
anova(m1_a)
```

Estimated marginal means

```{r}
emmeans(m1_a, ~ gen)
```
