---
title: "Factorial Design"
---


## Background

Factorial design involves studying the impact of multiple factors simultaneously. Each factor can have multiple levels, and combinations of these levels form the experimental conditions. This design allows us to understand the main effects of individual factors and their interactions on the response variable. The statistical model for factorial design is:
$$y_{ij} = \mu +  \tau_i+ \beta_j + \epsilon_{ij}$$ Where:
$\mu$ = experiment mean, $\tau$ = effect of factor A, $\beta$ = effect of factor B, and $\tau\beta$ = interaction effect of factor A and B.

Assumptions of this model includes: independent and identically distributed error terms with a constant variance.

::: callout-note
## A note
:::

## Example Analysis
First step is to load the libraries required for the analysis:

::: panel-tabset
### lme4


```{r, message=FALSE, warning=FALSE}
library(lme4); library(lmerTest); library(emmeans)
library(dplyr); library(broom.mixed); library(performance)
```


### nlme


```{r, message=FALSE, warning=FALSE, eval=FALSE}
library(nlme); library(broom.mixed); library(emmeans)
library(dplyr)
```

:::
Next, we will load the data set named 'cochran.factorial' from the 'agridat' package.
1.  **A 4x4 Factorial design**

The response variable: yield

A data frame with 32 observations on the following 4 variables.

-   rep: replication factor

-   block: block factor

-   trt: treatment factor, 16 levels

There were 4 treatment factors: d (dung treatment, 2 levels), n (nitrogen treatment, 2 levels), p (phosphorous treatment, 2 levels), and k (potassium treatment, 2 levels)


```{r}
library(agridat)

data1 <- agridat::cochran.factorial %>% mutate(d = as.factor(d),
         n = as.factor(n),
         p = as.factor(p),
         k = as.factor(k))
str(data1)
```


## Model fitting

Model fitting with R is exactly the same as shown in previous chapters: we need to include all effect, as well as the interaction, which is represented by using the colon indicator ‘:’. Therefore, model syntax is:

`yield ~ d + n + p + k + d:n + d:p + d:k + n:p + n:k + p:k + d:n:p:k`

which can be abbreviated as:

`yield ~ d*n*p*k`


```{r}
model1 <- lmer(yield ~ d*n*p*k + (1|block),
                   data = data1, 
                   na.action = na.exclude)

summary(model1)
```


::: callout-note
## Model fit using lme()

This same model can be fitted by using `lme()` from the 'nlme' package as well.


```{r, eval=FALSE}
model2 <- lme(yield ~ d*n*p*k,
              random = ~1|block,
                   data = data1, 
                   na.action = na.exclude)

model2 
anova(model2)
```


The results are same from both models with `lmer()` or `lme()`.
:::


```{r}
anova(model1)
```


### Check Model Assumptions

the residuals seem to fit the assumption required for normality.


```{r, "performance"}
check_model(model1)
```


### Inference


```{r}
m1 <- emmeans(model1, specs = ~ d|k)
m1
pairs(m1)
```

```{r}
m2 <- emmeans(model1, specs = ~ n)
m2
pairs(m2)
```


2.  Unbalanced factorial design

### *Data integrity checks*

### Model Building

::: column-margin
Recall the model:

$$                $$
:::

Here is the R syntax for that statistical model:

::: panel-tabset
### lme4


```{r}

```


### nlme


```{r}

```

:::

### Flotsam & Jetsam

