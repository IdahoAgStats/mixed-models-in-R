## Repeated measures

Studies that involve repeated observations of the exact same experimental units require a repeated measures component to properly model correlations across time with the experiment unit. This is common in any perennial crop that is evaluated across years, hay crops subject to repeat cuttings, and many other circumstances. In these models, the 'iid' assumption (idependently and identically distributed) is being violated, so we need to introduce specialized covariance structures that can account for these correlations between error terms.

There are several types of structures.

The repeated measures syntax in ***nlme*** follow this convention: `form = ~ time|grouping`. You can also use `1|group` and the observation order for each group will be. The default starting value (`value`) is zero, and if `fixed = FALSE` (the current nlme default), this value will be allowed to change during the model fitting process.

There are several other options in the **nlm** machinery (search "cor" for more options and details on the syntax).

Fitting models with correlated observations requires new libraries including mmrm and nlme. lmer allows random effects only.

### Talk about different covariance structures and provide reference for details

Packages required for this tutorial:

```{r}
#| message: false
#| warning: false
library(dplyr) 
library(nlme)
library(mmrm)
library(emmeans)
library(performance)
```

1.  **Repeated Measures RCBD**

The example shown below contains yield data

```{r}
dat <- agriTutorial::sorghum
```

```{r}
agridat::caribbean.maize
```

2.  **Split plot repeated measures**
    -   **using mmrm() from mmrm package:**

The example shown below contains yield data in a split-plot design. In this data set, we have:

Variety: 2 levels

Fertilizer: 3 levels

Replications: 4

The yield data was collected repeatedly from the same Reps over 5 'Sample_times'.

This can be analyze either using `nlme` or `mmr`.

Using mmr package:

```{r}
library(readr)
Yield <- read_csv(here::here("data/Yield.csv"))
head(Yield)
str(Yield)
```

To use mmrm(), we first need to convert Variety, Fertilizer, and Sample_time as factors. In addition, we need to create a new variable named 'plot' with a unique value for each plot. The plot will be used as a subject with repeated measures. The subject variable can be factor or numeric but the time (it could be year, or sample_time) has to be a factor.

```{r}
Yield$Variety <- factor(Yield$Variety)
Yield$Fertilizer <- factor(Yield$Fertilizer)
Yield$Sample_time1 <- factor(Yield$Sample_time)
Yield$Rep <- factor(Yield$Rep)

table(Yield$Fertilizer, Yield$Variety)
##creating a plot variable
Yield$plot <- factor(paste(Yield$Rep, Yield$Fertilizer, Yield$Variety, sep='-'))
Yield$Rep2 <- factor(paste(Yield$Rep, Yield$Variety, sep='-'))
table(Yield$plot)

```

## Model fit

```{r}

fit1 <- mmrm(
  formula = Yield ~ Variety + Fertilizer + Sample_time1 + Variety*Fertilizer +  + ar1(Sample_time1|Rep/plot),
  data = Yield,
   reml = FALSE
)
summary(fit1)

fit2 <- mmrm(
  formula = Yield ~ Variety + Fertilizer + Sample_time1 + Variety*Fertilizer +  + ar1(Sample_time1|Rep2/plot),
  data = Yield,
   reml = FALSE
)

summary(fit2)

anova(fit1, fit2)

asp.fit <- mmrm(Yield ~ Variety + Fertilizer + Sample_time1 + Variety:Fertilizer +  + ar1(Sample_time1|Rep/plot),
data=Yield)
summary(asp.fit)
```

Model Diagnostics

```{r}

##check_model(asp.fit) ## performance package doesn't work with mmrm class.
plot(residuals(asp.fit))
qqnorm(residuals(asp.fit)); qqline(residuals(asp.fit))
```

Anova

```{r}
# type III tests
Anova.mmrm(asp.fit, type = "III") ## some issues with it

# type III tests
joint_tests(asp.fit)
```

Post-Hoc comparison

```{r}
# cell means
asp.emm <- emmeans(asp.fit, c('Variety','Fertilizer'))
pairs(asp.emm)
joint_tests(asp.emm)


asp.emm1 <- emmeans(asp.fit1, c('trt.f','year.f'))
joint_tests(asp.emm1)
```

-   **using lme() from nlme package.**

```{r}

corr_str1 = corAR1(form = ~ Sample_time|Rep/Variety/plot, value = 0.2, fixed = FALSE)
corr_str2 = corCompSymm(form = ~ Sample_time|Rep/Variety/plot, fixed = FALSE)


# establish model2
mod <- lme(Yield ~ Sample_time1*Variety*Fertilizer,
                random = ~ 1|Rep/Variety/plot,
                data = Yield, na.action= na.exclude)

mod1 <- update(mod, corr= corr_str1)
mod2 <- update(mod, corr= corr_str2)

##compare different correlation matrices

anova(mod1, mod2)

```

```{r}
anova(mod1)
```

```{r}
emm <- emmeans(mod1,~ Sample_time1*Variety|Fertilizer)
pairs(emm)
```

```{r}
library(agridat)
data("durban.splitplot")
data("brandle.rape")

data1 <- brandle.rape
table(data1$gen, data1$loc)
```

```{r}
data("hunter.corn")
data2 <- hunter.corn

table(data2$nitro, data2$loc, data2$year)
```

The biggest advantage of mixed models is their incredible flexibility. They handle clustered individuals as well as repeated measures (even in the same model). They handle [crossed random factors](https://www.theanalysisfactor.com/multilevel-models-with-crossed-random-effects/) as well as nested

The biggest disadvantage of mixed models, at least for someone new to them, is their incredible flexibility. It’s easy to mis-specify a mixed model, and this is a place where a little knowledge is definitely dangerous.
